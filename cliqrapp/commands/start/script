#!/usr/bin/env bash

# To implement this command, edit the "Command implementation" section below. 

# Usage
# -----

# Comments prefixed with `#/` are managed by stubbs.
# The `command` and `usage` comments describe the command
# and show its options.
# 
#/ command: cliqrapp:start: "submit a job to ccm"
#/ usage: rerun cliqrapp:start [ --runname <>] [ --env_name <>] [ --ClusterName <>] [ --type <m1.medium>]  --wait <no> [ --job_list <>] [ --fmwbaseappid <295>] [ --fmwdepend <no>] [ --environment <PI>] [ --cloud <DTV_AWS_DevPI-us-west-2>] [ --subnet <subnet-02bf4e5b>] [ --vpc <vpc-82a873e7>] [ --vip_pool <updawebpi-aws_POOL>]  --cloud_tag <VMWEE> [ --version <>] [ --debug <no>] [ --fmw_job_list <>] [ --fmwinfo <>] [ --env_pairs <>] [ --appid <>] 

# Load common functions
# ---------------------

# Load the function library for this module.
# This loads rerun functions, too.
. $RERUN_MODULE_DIR/lib/functions.sh start || { 
  echo >&2 "Failed loading function library." ; exit 1 ; 
}

# Error handling
# ---------------

# This script is designed to _fail-fast_.

# Trap errors and exit. The call to `rerun_die` will print the
# the error message and exit with the error command exit status. 

trap 'rerun_die $? "*** command failed: cliqrapp:start. ***"' ERR

# Run [set] `nounset` to treat unset variables as errors. Set [pipefail]
# so a pipeline return status is the value of the last 
# (rightmost) command to exit with non-zero status.
#
# [set]: http://ss64.com/bash/set.html
# [pipefail]: http://www.gnu.org/software/bash/manual/html_node/Pipelines.html

set -o nounset -o pipefail

# Command variables
# -----------------

# This command script can access the following variables
# declared by `rerun` or by the option parser function.

#/ rerun-variables: RERUN, RERUN_VERSION, RERUN_MODULES, RERUN_MODULE_DIR
#/ option-variables: RUNNAME ENV_NAME CLUSTERNAME TYPE WAIT JOB_LIST FMWBASEAPPID FMWDEPEND ENVIRONMENT CLOUD SUBNET VPC VIP_POOL CLOUD_TAG VERSION DEBUG FMW_JOB_LIST FMWINFO ENV_PAIRS APPID

# The `rerun_options_parse` function processes the command line
# arguments. Each accepted command line flag results in setting 
# one the corresponding option variables.

rerun_options_parse "$@"


# Command implementation
# ----------------------
test -f ~/.cliqr.env && . ~/.cliqr.env
export SUBMIT_FILE=/tmp/submit.$$.json
export OUT=/tmp/submit.$$.out
export url="https://$SERVER/v1/jobs/"
export J=/tmp/jobs.$$.json
export DATESTAMP=`date '+%y%m%d%H%M%S'`
echo Extracting the app name
export APPNAME=`rerun cliqrapp: apps --appid $APPID --shownameonly yes|sed s/:/_/g`
echo App name is $APPNAME
test X$RUNNAME = X -o X$RUNNAME = Xundef && export RUNNAME=$APPNAME-$ENV_NAME-${DATESTAMP}
export CLUSTER_LINES=""
export TYPE_LINE=""
export DEBUG_LINES=""
export FMWINFO_LINES=""
if [ X$FMWDEPEND = Xyes ]
then
   echo looking for --appid $FMWBASEAPPID
   FOUND=`rerun cliqrapp: jobs --env_name $ENV_NAME --appid $FMWBASEAPPID --quiet yes`
   if echo $FOUND |grep found
   then
      echo We Found a runnig job with appid $FMWBASEAPPID $FOUND
   else
      echo starting a new app $FMWBASEAPPID First
      rerun cliqrapp: start --appid $FMWBASEAPPID --env_name $ENV_NAME --cloud_tag $CLOUD_TAG --wait yes --fmwdepend no --runname "undef" --job_list ${FMW_JOB_LIST:=undef}
      JOBID=`cat ~/.last.jobid`
      ADM_SERVER=`rerun cliqrapp: jobs --id $JOBID --getipfornode ADMRAC --quiet yes`
   fi
   admserver=`rerun cliqrapp: jobs --env_name $ENV_NAME --appid $FMWBASEAPPID --quiet yes --getipfornode ADM`
   if [ X${admserver} = X ]
	then
		echo Can not find the admin server for  $FMWBASEAPPID $FOUND
		exit 0
	else
		
		FMWINFO=$admserver:${WLDOMPW:=welc0me1}:${NM_PASSWORD:=welc0me1}
        fi
fi
case $CLOUD_TAG in 
VMWEE)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMware_EEPOP-MSDC"
        ENVIRONMENT="MSDC_EE"
	;;
VMWPI)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMware_EEPOP-MSDC"
        ENVIRONMENT="MSDC_PI"
	;;
VMW-SB-EE)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMware_EEPOP-MSDC"
        ENVIRONMENT="MSDC_SBEE"
	;;
VMW-SB-PI)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMware_EEPOP-MSDC"
        ENVIRONMENT="MSDC_SBPI"
	;;
#AWSEE)
	#CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	#CLOUD="DTV_AWS_DevPI-us-west-2"
        #ENVIRONMENT="AWS_EE"
	#;;
#AWSPI)
	#CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	#CLOUD="DTV_AWS_DevPI-us-west-2"
        #ENVIRONMENT="AWS_PI"
	#;;
CRP_PROD)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMWARE_CR_POP-01"
        ENVIRONMENT="CRP_PROD"
	;;
NJP_PROD)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMWARE_NJ_POP-01"
        ENVIRONMENT="NJP_PROD"
	;;
LAP_PROD)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMWARE_LA_POP-01"
        ENVIRONMENT="LAP_PROD"
	;;
VAP_PROD)
	CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	CLOUD="DTV_VMWARE_VA_POP-01"
        ENVIRONMENT="VAP_PROD"
	;;
#MSDC_EEPOP2)
	#CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
	#CLOUD="DTV_VMware_EEPOP-MSDC"
        #ENVIRONMENT="MSDC_EEPOP2"
	#;;
*)
	if [ -f $RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE ]
        then
                CLOUDPARAMS=$RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE
		#echo '{' `cat NJP_PROD.TAGFILE` '}' |jq -r '.cloudParams.cloudProperties[]| select( .name == "UserClusterName" )| .value'
		#CLOUD=`sed '1s/^/{/' $CLOUD_TAG.TAGFILE|sed '$s/$/}/'|jq -r '.cloudParams.cloudProperties[]| select( .name == "UserClusterName" )| .value'`
		CLOUD=`sed '1s/^/{/' $RERUN_MODULE_DIR/lib/$CLOUD_TAG.TAGFILE|sed '$s/$/}/'|jq -r '.cloudParams.cloud'`
		ENVIRONMENT=`echo $CLOUD_TAG|sed s/_C[1234]*$//`

	else
		cd $RERUN_MODULE_DIR/lib/
	        echo CLOUD_TAG not defined use one of this *.TAGFILE |sed s/.TAGFILE//g
                exit 0
        fi 
	;;
esac
test X$CLUSTERNAME != X && CLUSTER_LINES=",
                     {
                           \"name\":\"ClusterName\",
                           \"value\":\"$CLUSTERNAME\"
                     }
"

test X${DEBUG:=} = Xyes && DEBUG_LINES=",
                     {
                           \"name\":\"cliqrIgnoreAppFailure\",
                           \"value\":\"true\"
		     },
                     {
                           \"name\":\"IBDNS\",
                           \"value\":\"yes\"
                     }
"
test X$VIP_POOL != X && VIP_LINES=",
                     {
                           \"name\":\"VIP_POOL_NAME\",
                           \"value\":\"$VIP_POOL\"
                     }
"

if [ "X${FMWINFO:=}" != X ]
then
IFS=:
set ${FMWINFO}
unset IFS
ADM_HOST_NAME=$1
if [ $ADM_HOST_NAME = LAST ]
then
  export LASTRUN=`grep $FMWBASEAPPID: ~/.last.jobid|tail -1|cut -d: -f 2`
  if [ ${LASTRUN:=null} = null ]
  then
	echo can not find a run for $FMWBASEAPPID
        exit 1
  fi
  ADM_HOST_NAME=`rerun cliqrapp: jobs --id $LASTRUN --getipfornode ADMRAC --quiet yes`
fi
echo ADM_HOST_NAME=$ADM_HOST_NAME
if nmap -p 7001 ${ADM_HOST_NAME}|grep "7001/tcp open" >/dev/null
then 
      echo 
else 
      echo ${ADM_HOST_NAME}:7001 is not open ??????
      sleep 3
      echo ${ADM_HOST_NAME}:7001 is not open ??????
      sleep 3
      echo ${ADM_HOST_NAME}:7001 is not open ??????
      sleep 3
      echo ${ADM_HOST_NAME}:7001 is not open ??????
      sleep 3
      echo Continuing anyways.
fi

WLDOMPW=$2
NM_PASSWORD=$3
FMWINFO_LINES=",
                     {
                           \"name\":\"ADM_HOST_NAME\",
                           \"value\":\"$ADM_HOST_NAME\"
                     },
                     {
                           \"name\":\"WLDOMPW\",
                           \"value\":\"$WLDOMPW\"
                     },
                     {
                           \"name\":\"NM_PASSWORD\",
                           \"value\":\"$NM_PASSWORD\"
                     }
"
fi
ENV_PAIRS_LINES=""
if [ "X${ENV_PAIRS:=}" != X ]
then
for env_pair in `echo ${ENV_PAIRS}|sed 's/,/ /g'`
do
N=`echo $env_pair|awk -F= '{print $1}'`
V=`echo $env_pair|awk -F= '{print $2}'`
ENV_PAIRS_LINES="$ENV_PAIRS_LINES
		     ,
                     {
                           \"name\":\"$N\",
                           \"value\":\"$V\"
                     }
"
done
fi
#echo $ENV_PAIRS_LINES
#read
VERSION_LINE=""
echo ""
#test X$APPID != X$FMWBASEAPPID -a X$VERSION != X && VERSION_LINE="\"appVersion\":\"$VERSION\","
test X$VERSION != X && VERSION_LINE="\"appVersion\":\"$VERSION\","
#test [ X$APPID != X$FMWBASEAPPID &&  X$VERSION != X ] && VERSION_LINE="\"appVersion\":\"$VERSION\","
#test X$VERSION != X && VERSION_LINE=",
                           #\"name\":\"appVersion\",
                           #\"value\":\"$VERSION\"
                     #}
#"
JOBSTEMP=/tmp/jobs.tmp.$$
>$JOBSTEMP
if [ "X${JOB_LIST}" = X -o "X${JOB_LIST}" = Xundef ]
then
	if [ -f $RERUN_MODULE_DIR/lib/$APPID.$CLOUD_TAG.txt ]
	then
	  JOB_LIST="`cat $RERUN_MODULE_DIR/lib/$APPID.$CLOUD_TAG.txt`"
	else
	  if [ X${VERSION} =  X ]
	  then
	       JOB_LIST=`rerun cliqrapp: apps --appid $APPID|jq -r .serviceTierId|awk -F- '{print $2":'$TYPE'"}'`
	  else
	       JOB_LIST=`rerun cliqrapp: apps --appid $APPID --version ${VERSION} |jq -r .serviceTierId|awk -F- '{print $2":'$TYPE'"}'`
	  fi
          echo JOB_LIST was not predefined using "$JOB_LIST"
	fi
fi
echo $JOB_LIST
sleep 5
for job in $JOB_LIST
do
   IFS=:
   set $job
   TIRE=$1
   STTYPE=$2
   if [ ${API_VERSION:=3} -ge 4 ]
   then
 	STTYPE=`rerun cliqrapp: type-lookup --typename $STTYPE --cloud_tag $CLOUD_TAG`
   fi
   NUM_OF_NODES_LINES=""
echo TIRE:TYPE=$TIRE:$STTYPE
if [ ! -z "${3+x}" ]
then
COUNT=${3}
NUM_OF_NODES_LINES="
,
                     {
                           \"name\":\"minClusterSize\",
                           \"value\":\"${COUNT}\"
                     }
"
fi
   cat <<EOF >>$JOBSTEMP
{
                     "serviceTierId":"A-$TIRE",
                     "parameters":{
                           "appParams":[
                                  {
                                         "name":"ENV_NAME",
                                         "value":"$ENV_NAME"
                                  }
$VIP_LINES
$DEBUG_LINES
$CLUSTER_LINES
$NUM_OF_NODES_LINES                           ],

`cat  $CLOUDPARAMS|sed "s/STTYPE/$STTYPE/g"`
                     }
}
,
EOF
done
unset IFS
JOB_LINES=`cat $JOBSTEMP|sed '$d'`
cat <<EOF >$SUBMIT_FILE
{
       "serviceTierId":"A-$APPID",
       "name":"$RUNNAME",
       "environment":"$ENVIRONMENT",
$VERSION_LINE
       "jobs":[
$JOB_LINES
       ],
       "parameters":{
`cat  $CLOUDPARAMS|sed "s/STTYPE/$STTYPE/g"`
,
              "appParams":[
                     {
                           "name":"ENV_NAME",
                           "value":"$ENV_NAME"
                     }
$VIP_LINES
$FMWINFO_LINES
$ENV_PAIRS_LINES
$DEBUG_LINES
$CLUSTER_LINES
              ]
       }
}


EOF
#jq . $SUBMIT_FILE
#read
#set -x 
curl -sS -i -k -X POST -u $API_USER:$API_PASSWORD -H "Content-Type: application/json" -d @- https://$SERVER/v1/jobs/ <$SUBMIT_FILE >$OUT
cut -c1-254 $OUT
LOC=`grep 'Location:' $OUT |sed 's/#Location://'`
JOBID=`echo $LOC|awk -F/ '{print $6}'`
if [ ${WAIT:=no} != no ]
then
  sleep 6
  test $WAIT = yes && WAIT=60
  rerun cliqrapp: wait --id $JOBID --wait $WAIT
fi
echo $APPID:$JOBID >>~/.last.jobid

# Done. Exit with last command exit status.
exit $?

